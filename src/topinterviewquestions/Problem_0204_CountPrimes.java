package topinterviewquestions;

/**
 * @author ：Lisp
 * @date： 2021/10/10
 * @version: V1.0
 * @slogan:
 * @description :统计所有小于非负整数 n 的质数的数量。
 *
 * 【解法一 埃氏筛】接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞（\rm EratosthenesEratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛
 * 如果 xx 是质数，那么大于 xx 的 xx 的倍数 2x,3x,… 一定不是质数，因此我们可以从这里入手。
 *
 * 我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，
 * 则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。
 *
 * 这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，
 * 当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，
 * 我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。
 *
 * 当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，
 * 因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。
 *
 * 时间复杂度：O(nloglogn)。证明不需要掌握，知道结论即可。
 * 空间复杂度：O(n)，用来标记是否为质数
 *
 *【方法二 线性筛】
 * 这题还有更好的筛法——线性筛，但不属于笔试/面试范畴，不需要掌握
 *
 */
public class Problem_0204_CountPrimes {

    public int countPrimes(int n) {

        if (n < 3) {
            return 0;
        }

        // 是否已经计算判断过的数
        boolean[] f = new boolean[n];

        // 先筛除2的倍数的所有数 剩下最多有n/2个数可能是质数
        // 2 4 6 8 10 12 14 16...
        int count = n/2;
        // 如果一个数是合数 则一定可以分解成 一个小于 x½  和一个大于 x½ 所以i只需要尝试 小于根号x即可
        for (int i = 3; i *i < n; i+=2) {
            // i+=2 表示i著需要判断奇数的倍数即可 如 3 5 7 9 偶数不需要判断了
            if (f[i]) {
                continue;
            }
            // 筛除 3  2*3(√)     3*3                  4*3(√)     5*3        6*3(√)    7*3 ...
            // 筛除 5  2*5(√)     3*5(√上一行算过)      4*5(√)     5*5        6*5(√)    7*5 ...
            // 筛除 7  2*7(√)     3*7(√)               4*7(√)     5*7(√上一行算过)     6*7 (√)   7*7 ...

            // 3*3 5*3 7*3 9*3...
            for (int j = i; j * i < n; j += 2) {
                if (!f[j * i]) {
                    f[j * i] = true;
                    count--;
                }
            }
        }

        return  count;
    }

}
