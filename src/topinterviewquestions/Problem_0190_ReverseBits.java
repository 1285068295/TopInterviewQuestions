package topinterviewquestions;

/**
 * @author ：Lisp
 * @date： 2021/10/10
 * @version: V1.0
 * @slogan:
 * @description :
 */
public class Problem_0190_ReverseBits {




    // 代码看着很魔幻吧？
    // 给个例子，假设n二进制为：
    // 1011 0111 0011 1001 0011 1111 0110 1010
    // 解释一下，第一行，是把n左边16位，和n右边16位交换
    // n = (n >>> 16) | (n << 16);
    // 因为 n >>> 16 就是左边16位被移动到了右侧
    // 同时 n << 16  就是右边16位被移动到了左侧
    // 又 | 在了一起，所以，n变成了
    // 0011 1111 0110 1010 1011 0111 0011 1001

    // 第二行，
    // n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
    // (n & 0xff00ff00)
    // 这一句意思是，左侧开始算0~7位，保留；8~15位，全变0；16~23位，保留；24~31位，全变0
    // 0011 1111 0000 0000 1011 0111 0000 0000
    // (n & 0xff00ff00) >>> 8 这句就是上面的值，统一向右移动8位，变成：
    // 0000 0000 0011 1111 0000 0000 1011 0111
    //
    //
    // (n & 0x00ff00ff)
    // 这一句意思是，左侧开始算0~7位，全变0；8~15位，保留；16~23位，全变0；24~31位，保留
    // 0000 0000 0110 1010 0000 0000 0011 1001
    // (n & 0x00ff00ff) << 8 这句就是上面的值，统一向左移动8位，变成：
    // 0110 1010 0000 0000 0011 1001 0000 0000
    // 那么 ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8)
    // 什么效果？就是n的0~7位和8~15位交换了，16~23位和24~31位交换了
    // 0110 1010 0011 1111 0011 1001 1011 0111

    // 也就是说，整个过程是n的左16位，和右16位交换
    // n的左16位的内部，左8位和右8位交换；n的右16位的内部，左8位和右8位交换
    // 接下来的一行，其实是，从左边开始算，0~7位内部，左4和右4交换；8~15位，左4和右4交换；...
    // 接下来的一行，其实是，从左边开始算，0~3位内部，左2和右2交换；4~7位，左2和右2交换；...
    // 最后的一行，其实是，从左边开始算，0~1位内部，左1和右1交换；2~3位，左1和右1交换；...


    /**
     * 老师的解答  思路 高16位与第16位反转  高八位与低八位反转...
     * @param n
     * @return
     */
    public static int reverseBits(int n) {
        // n
        n = (n >>> 16) | (n << 16);
        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
        return n;
    }


    /**
     * 按照老师的思路  利用递归来实现  借助数组作为辅助空间进行反转
     * 递归函数 在L到R返回上实现反转
     */
    public static int reverseBits2(int n) {
        // n
        int[] arr = new int[32];
        for (int i = 0; i < 32; i++) {
            arr[i] = n  & 1;
            n = n >> 1;
        }

        int L =0;
        int R = 31;
        while (L < R){
            int tmp = arr[L];
            arr[L] = arr[R];
            arr[R] = tmp;
            L++;
            R--;
        }

        int ans = 0;
        int t = 1;
        for (int i = 0; i < 32; i++) {
            ans += (t) * arr[i];
            t = t << 1;
        }
        return ans;
    }


    public static void main(String[] args) {
        // 0000 0000 0000 1011
        // 1101 0000 0000 0000

        // 00000010100101000001111010011100
        // 001110010111100000101001010000000

        System.out.println(reverseBits2(0b00000010100101000001111010011100));

    }



}
